// Generated by CoffeeScript 1.3.1
var Page, Route, cancelRender, mapRoute, mergeAll, passThroughNoPage, qs, renderMapped, renderQueued, util;

qs = require('qs');

Route = require('express/lib/router/route');

mergeAll = require('racer').util.mergeAll;

util = require('./util');

passThroughNoPage = function(model, params, next) {
  return next();
};

exports.addHttpMethods = function(appExports) {
  var routes;
  routes = {
    queue: {},
    map: {}
  };
  ['get', 'post', 'put', 'del'].forEach(function(method) {
    var map, queue;
    queue = routes.queue[method] = [];
    map = routes.map[method] = [];
    return appExports[method] = function(pattern, callback, callback2) {
      var back, forward, from, fromRoute, to, toRoute;
      if (typeof pattern === 'object') {
        from = pattern.from, to = pattern.to;
        forward = pattern.forward || callback.forward || callback;
        back = pattern.back || callback.back || callback2 || passThroughNoPage;
        fromRoute = new Route(method, from, back);
        toRoute = new Route(method, to, forward);
        map.push({
          from: fromRoute,
          to: toRoute
        }, {
          from: toRoute,
          to: fromRoute
        });
        queue.push(new Route(method, to, function(page, model, params, next, reroute) {
          var render;
          render = page.render;
          page.render = function(ns, ctx) {
            forward(model, params, next);
            page.render = render;
            return page.render(ns, ctx);
          };
          return reroute(mapRoute(from, params));
        }));
        return;
      }
      queue.push(new Route(method, pattern, callback));
      return appExports;
    };
  });
  return routes;
};

Page = exports.Page = function(view, model) {
  this.view = view;
  this.model = model;
};

Page.prototype = {
  render: function(ns, ctx) {
    return this.view.render(this.model, ns, ctx);
  },
  redirect: function(url) {
    if (url === 'back') {
      return this.view.history.back();
    }
    if (url === 'home') {
      url = '\\';
    }
    return this.view.history.replace(url, true);
  }
};

exports.mapRoute = mapRoute = function(from, params) {
  var i, path, queryString, url;
  url = params.url;
  queryString = ~(i = url.indexOf('?')) ? url.slice(i) : '';
  i = 0;
  path = from.replace(/(?:(?:\:([^?\/:*]+))|\*)\??/g, function(_, key) {
    if (key) {
      return params[key];
    }
    return params[i++];
  });
  return path + queryString;
};

cancelRender = function(url, form, e) {
  if (e) {
    return;
  }
  if (form) {
    form._forceSubmit = true;
    return form.submit();
  } else {
    return window.location = url;
  }
};

exports.render = function(page, routes, previous, url, method, e, body, form) {
  var map, onMatch, path, query, queryString, queue, reroute, _ref;
  url = url.replace(/#.*/, '');
  _ref = url.split('?'), path = _ref[0], queryString = _ref[1];
  body || (body = {});
  query = queryString ? qs.parse(queryString) : {};
  map = routes.map[method];
  queue = routes.queue[method];
  reroute = function(url) {
    var i;
    path = ~(i = url.indexOf('?')) ? url.slice(0, i) : url;
    return renderQueued(previous, path, url, form, null, onMatch, map, queue, 0);
  };
  onMatch = function(path, url, i, route, renderNext, noPage) {
    var next, params, routeParams, run;
    if (e) {
      e.preventDefault();
    }
    routeParams = route.params;
    params = routeParams.slice();
    mergeAll(params, routeParams, {
      url: url,
      body: body,
      query: query
    });
    next = function(err) {
      if (err != null) {
        return cancelRender(url, form);
      }
      return renderNext(previous, path, url, form, null, onMatch, map, queue, i);
    };
    run = noPage ? function() {
      return route.callbacks(page.model, params, next);
    } : function() {
      return route.callbacks(page, page.model, params, next, reroute);
    };
    if (util.DEBUG) {
      return run();
    }
    try {
      run();
    } catch (err) {
      cancelRender(url, form);
    }
  };
  return renderMapped(previous, path, url, form, e, onMatch, map, queue, 0);
};

renderMapped = function(previous, path, url, form, e, onMatch, map, queue, i) {
  var item;
  while (item = map[i++]) {
    if (!item.to.match(path)) {
      continue;
    }
    if (!item.from.match(previous)) {
      continue;
    }
    return onMatch(path, url, i, item.to, renderMapped, true);
  }
  return renderQueued(previous, path, url, form, e, onMatch, map, queue, 0);
};

renderQueued = function(previous, path, url, form, e, onMatch, map, queue, i) {
  var route;
  while (route = queue[i++]) {
    if (!route.match(path)) {
      continue;
    }
    return onMatch(path, url, i, route, renderQueued);
  }
  return cancelRender(url, form, e);
};
