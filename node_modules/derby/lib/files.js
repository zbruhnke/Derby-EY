// Generated by CoffeeScript 1.3.1
var Promise, basename, compactHtml, crypto, dirname, exists, extensions, files, findPath, finishAfter, fs, hashFile, ignoreDirectories, ignored, join, less, loadTemplates, nib, onlyWhitespace, parseHtml, parseTemplateFile, racer, relative, styleCompilers, stylus, trim, _ref;

_ref = require('path'), dirname = _ref.dirname, basename = _ref.basename, join = _ref.join, exists = _ref.exists, relative = _ref.relative;

fs = require('fs');

crypto = require('crypto');

stylus = require('stylus');

nib = require('nib');

less = require('less');

racer = require('racer');

parseHtml = require('./html').parse;

trim = require('./View').trim;

Promise = racer.util.Promise;

finishAfter = racer.util.async.finishAfter;

styleCompilers = {
  stylus: function(root, clientName, compress, callback) {
    return findPath(root + '/styles', clientName, '.styl', function(path) {
      if (!path) {
        return callback('');
      }
      return fs.readFile(path, 'utf8', function(err, styl) {
        if (err) {
          return callback(err);
        }
        return stylus(styl).use(nib()).set('filename', path).set('compress', compress).render(callback);
      });
    });
  },
  less: function(root, clientName, compress, callback) {
    return findPath(root + '/styles', clientName, '.less', function(path) {
      if (!path) {
        return callback('');
      }
      return fs.readFile(path, 'utf8', function(err, lessFile) {
        var parser;
        if (err) {
          return callback(err);
        }
        parser = new less.Parser({
          paths: [root + '/styles'],
          filename: path
        });
        return parser.parse(lessFile, function(err, tree) {
          if (err) {
            return callback(err);
          }
          return callback(null, tree.toCSS({
            compress: compress
          }));
        });
      });
    });
  }
};

module.exports = {
  css: function(root, clientName, compress, callback) {
    var compiler, concatStyles, finish, style, styles, _i, _len, _results;
    concatStyles = '';
    styles = require('./derby').settings.styles;
    styles || (styles = ['less', 'stylus']);
    if (!Array.isArray(styles)) {
      styles = [styles];
    }
    finish = finishAfter(styles.length, function(err) {
      return callback(err, concatStyles);
    });
    _results = [];
    for (_i = 0, _len = styles.length; _i < _len; _i++) {
      style = styles[_i];
      compiler = styleCompilers[style];
      if (!compiler) {
        finish(new Error('Unable to find compiler for: ' + style));
      }
      _results.push(compiler(root, clientName, compress, function(err, contents) {
        concatStyles += contents || "";
        return finish(err);
      }));
    }
    return _results;
  },
  templates: function(root, clientName, callback) {
    var calls, count;
    count = 0;
    calls = {
      incr: function() {
        return count++;
      },
      finish: function(err, templates, instances) {
        if (err) {
          calls.finish = function() {};
          return callback(err);
        }
        return --count || callback(null, templates, instances);
      }
    };
    return loadTemplates(root + '/views', clientName, 'import', calls);
  },
  js: function(parentFilename, options, callback) {
    var finish, inline, inlineFile, js;
    if (!parentFilename) {
      return;
    }
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    if (options.ignore) {
      options.ignore.push('mime');
    } else {
      options.ignore = ['mime'];
    }
    if (options.require) {
      options.require.push(parentFilename);
    } else {
      options.require = [parentFilename];
    }
    inlineFile = join(dirname(parentFilename), 'inline.js');
    js = inline = null;
    finish = finishAfter(2, function(err) {
      return callback(err, js, inline);
    });
    racer.js(options, function(err, value) {
      js = value;
      return finish(err);
    });
    return fs.readFile(inlineFile, 'utf8', function(err, value) {
      inline = value;
      if (err && err.code === 'ENOENT') {
        err = null;
      }
      return finish(err);
    });
  },
  parseName: function(parentFilename, options) {
    var base, parentDir, root;
    root = parentDir = dirname(parentFilename);
    if ((base = basename(parentFilename, '.js')) === 'index') {
      base = basename(parentDir);
      root = dirname(dirname(parentDir));
    } else if (basename(parentDir) === 'lib') {
      root = dirname(parentDir);
    }
    return {
      root: root,
      clientName: options.name || base,
      require: './' + basename(parentFilename)
    };
  },
  hashFile: hashFile = function(s) {
    var hash;
    hash = crypto.createHash('md5').update(s).digest('base64');
    return hash.replace(/[\/\+=]/g, function(match) {
      switch (match) {
        case '/':
          return '-';
        case '+':
          return '_';
        case '=':
          return '';
      }
    });
  },
  writeJs: function(root, js, options, callback) {
    var filePath, filename, finish, hash, jsFile, staticDir, staticPath, staticRoot;
    staticRoot = options.staticRoot || join(root, 'public');
    staticDir = options.staticDir || 'gen';
    staticPath = join(staticRoot, staticDir);
    hash = hashFile(js);
    filename = hash + '.js';
    jsFile = join('/', staticDir, filename);
    filePath = join(staticPath, filename);
    finish = function() {
      return fs.writeFile(filePath, js, function(err) {
        return callback(err, jsFile, hash);
      });
    };
    return exists(staticPath, function(value) {
      if (value) {
        return finish();
      }
      return exists(staticRoot, function(value) {
        if (value) {
          return fs.mkdir(staticPath, '0777', function(err) {
            return finish();
          });
        }
        return fs.mkdir(staticRoot, '0777', function(err) {
          return fs.mkdir(staticPath, '0777', function(err) {
            return finish();
          });
        });
      });
    });
  },
  watch: function(dir, type, onChange) {
    var extension, options;
    options = {
      interval: 100
    };
    extension = extensions[type];
    return files(dir, extension).forEach(function(file) {
      return fs.watchFile(file, options, function(curr, prev) {
        if (prev.mtime < curr.mtime) {
          return onChange(file);
        }
      });
    });
  }
};

onlyWhitespace = /^[\s\n]*$/;

findPath = function(root, name, extension, callback) {
  var path;
  if (name.charAt(0) !== '/') {
    name = join(root, name);
  }
  path = name + extension;
  return exists(path, function(value) {
    if (value) {
      return callback(path);
    }
    path = join(name, 'index' + extension);
    return exists(path, function(value) {
      return callback(value ? path : null);
    });
  });
};

loadTemplates = function(root, fileName, get, calls, files, templates, instances, alias, currentNs) {
  if (currentNs == null) {
    currentNs = '';
  }
  calls.incr();
  return findPath(root, fileName, '.html', function(path) {
    var getCount, got, matchesGet, promise;
    if (path === null) {
      if (!files) {
        return calls.finish(null, {}, {});
      } else {
        return calls.finish(new Error("Can't find file " + fileName));
      }
    }
    files || (files = {});
    templates || (templates = {});
    instances || (instances = {});
    got = false;
    if (get === 'import') {
      matchesGet = function() {
        got = true;
        return true;
      };
    } else if (Array.isArray(get)) {
      getCount = get.length;
      matchesGet = function(name) {
        --getCount || (got = true);
        return ~get.indexOf(name);
      };
    } else {
      matchesGet = function(name) {
        got = true;
        return get === name;
      };
    }
    if (!(promise = files[path])) {
      promise = files[path] = new Promise;
      fs.readFile(path, 'utf8', function(err, file) {
        return promise.resolve(err, file);
      });
    }
    return promise.on(function(err, file) {
      if (err) {
        calls.finish(err);
      }
      parseTemplateFile(root, dirname(path), path, calls, files, templates, instances, alias, currentNs, matchesGet, file);
      if (!got) {
        calls.finish(new Error("Can't find template '" + get + "' in " + path));
      }
      return calls.finish(null, templates, instances);
    });
  });
};

compactHtml = function(html) {
  var compact, minifyContent, onTag, onText;
  compact = '';
  minifyContent = true;
  onTag = function(tag, _, attrs) {
    if (attrs.constructor === Object) {
      minifyContent = !('x-no-minify' in attrs);
    }
    return compact += tag.replace(/\n\s*/g, '\n');
  };
  onText = function(text) {
    return compact += minifyContent ? trim(text) : text;
  };
  parseHtml(html, {
    start: onTag,
    end: onTag,
    chars: onText
  });
  return compact;
};

parseTemplateFile = function(root, dir, path, calls, files, templates, instances, alias, currentNs, matchesGet, file) {
  var as, importTemplates, name, ns, relativePath, src, templateOptions;
  name = src = ns = as = importTemplates = templateOptions = null;
  relativePath = relative(root, path);
  return parseHtml(file, {
    start: function(tag, tagName, attrs) {
      var i, srcNs, template;
      name = src = ns = as = importTemplates = null;
      i = tagName.length - 1;
      name = (tagName.charAt(i) === ':' ? tagName.slice(0, i) : '').toLowerCase();
      if (name === 'import') {
        src = attrs.src, ns = attrs.ns, as = attrs.as, template = attrs.template;
        if (!src) {
          calls.finish(new Error("Template import in " + path + " must have a 'src' attribute"));
        }
        if (template) {
          importTemplates = template.toLowerCase().split(' ');
          if (importTemplates.length > 1 && (as != null)) {
            calls.finish(new Error("Template import of '" + src + "' in " + path + " can't specify multiple 'template' values with 'as'"));
          }
        }
        ns = 'ns' in attrs ? (as ? calls.finish(new Error("Template import of '" + src + "' in " + path + " can't specifiy both 'ns' and 'as' attributes")) : void 0, ns ? currentNs ? currentNs + ':' + ns : ns : currentNs) : as ? currentNs : (srcNs = src.replace(/^[.\/]*/, ''), currentNs ? currentNs + ':' + srcNs : srcNs);
        ns = ns.toLowerCase();
      } else {
        templateOptions = attrs;
      }
    },
    chars: function(text, literal) {
      var instanceName, templateName, toGet;
      if (!matchesGet(name)) {
        return;
      }
      if (src) {
        if (!onlyWhitespace.test(text)) {
          calls.finish(new Error("Template import of '" + src + "' in " + path + " can't contain content"));
        }
        toGet = importTemplates || 'import';
        return loadTemplates(root, join(dir, src), toGet, calls, files, templates, instances, as, ns);
      }
      templateName = relativePath + ':' + name;
      instanceName = alias || name;
      if (currentNs) {
        instanceName = currentNs + ':' + instanceName;
      }
      instances[instanceName] = [templateName, templateOptions];
      if (templates[templateName]) {
        return;
      }
      if (!(name && literal)) {
        if (onlyWhitespace.test(text)) {
          return;
        }
        calls.finish(new Error("Can't read template in " + path + " near the text: " + text));
      }
      return templates[templateName] = compactHtml(text);
    }
  });
};

extensions = {
  html: /\.html$/,
  css: /\.styl$|\.css|\.less$/,
  js: /\.js$/
};

ignoreDirectories = ['node_modules', '.git', 'gen'];

ignored = function(path) {
  return ignoreDirectories.indexOf(path) === -1;
};

files = function(dir, extension, out) {
  if (out == null) {
    out = [];
  }
  fs.readdirSync(dir).filter(ignored).forEach(function(p) {
    p = join(dir, p);
    if (fs.statSync(p).isDirectory()) {
      return files(p, extension, out);
    } else if (extension.test(p)) {
      return out.push(p);
    }
  });
  return out;
};
